CodeMirror.overlayParser = function (a, b, c) { return { startState: function () { return { base: CodeMirror.startState(a), overlay: CodeMirror.startState(b), basePos: 0, baseCur: null, overlayPos: 0, overlayCur: null} }, copyState: function (c) { return { base: CodeMirror.copyState(a, c.base), overlay: CodeMirror.copyState(b, c.overlay), basePos: c.basePos, baseCur: null, overlayPos: c.overlayPos, overlayCur: null} }, token: function (d, e) { d.start == e.basePos && (e.baseCur = a.token(d, e.base), e.basePos = d.pos), d.start == e.overlayPos && (d.pos = d.start, e.overlayCur = b.token(d, e.overlay), e.overlayPos = d.pos), d.pos = Math.min(e.basePos, e.overlayPos), d.eol() && (e.basePos = e.overlayPos = 0); if (e.overlayCur == null) return e.baseCur; return e.baseCur != null && c ? e.baseCur + " " + e.overlayCur : e.overlayCur }, indent: function (b, c) { return a.indent(b.base, c) }, electricChars: a.electicChars} }, CodeMirror.defineMode("javascript", function (a, b) { function R(a, b) { if (a == "variable") { v(b); return u() } } function Q(a, b) { if (a == "variable") { v(b); return u(Q) } if (a == "(") return u(x, I(R, ")"), C, y) } function P(a) { a != ")" && u(D) } function O(a, b) { if (a == ";") return u(P); if (b == "in") return u(D); return u(D, B(";"), P) } function N(a, b) { if (b == "in") return u(D); return u(E, O) } function M(a) { if (a == "var") return u(K, O); if (a == ";") return t(O); if (a == "variable") return u(N); return t(O) } function L(a, b) { if (b == "=") return u(D, L); if (a == ",") return u(K) } function K(a, b) { if (a == "variable") { v(b); return u(L) } return u() } function J(a) { if (a == "}") return u(); return t(C, J) } function I(a, b) { function c(d) { if (d == ",") return u(a, c); if (d == b) return u(); return u(B(b)) } return function (d) { return d == b ? u() : t(a, c) } } function H(a) { a == "variable" && (s.marked = "js-property"); if (o.hasOwnProperty(a)) return u(B(":"), D) } function G(a) { if (a == "variable") { s.marked = "js-property"; return u() } } function F(a) { if (a == ":") return u(A, C); return t(E, B(";"), A) } function E(a, b) { if (a == "operator" && /\+\+|--/.test(b)) return u(E); if (a == "operator") return u(D); if (a != ";") { if (a == "(") return u(z(")"), I(D, ")"), A, E); if (a == ".") return u(G, E); if (a == "[") return u(z("]"), D, B("]"), A, E) } } function D(a) { if (o.hasOwnProperty(a)) return u(E); if (a == "function") return u(Q); if (a == "keyword c") return u(D); if (a == "(") return u(z(")"), D, B(")"), A, E); if (a == "operator") return u(D); if (a == "[") return u(z("]"), I(D, "]"), A, E); if (a == "{") return u(z("}"), I(H, "}"), A, E); return u() } function C(a) { if (a == "var") return u(z("vardef"), K, B(";"), A); if (a == "keyword a") return u(z("form"), D, C, A); if (a == "keyword b") return u(z("form"), C, A); if (a == "{") return u(z("}"), J, A); if (a == ";") return u(); if (a == "function") return u(Q); if (a == "for") return u(z("form"), B("("), z(")"), M, B(")"), A, C, A); if (a == "variable") return u(z("stat"), F); if (a == "switch") return u(z("form"), D, z("}", "switch"), B("{"), J, A, A); if (a == "case") return u(D, B(":")); if (a == "default") return u(B(":")); if (a == "catch") return u(z("form"), x, B("("), R, B(")"), C, A, y); return t(z("stat"), D, B(";"), A) } function B(a) { return function (b) { return b == a ? u() : a == ";" ? t() : u(arguments.callee) } } function A() { var a = s.state; a.lexical.prev && (a.lexical.type == ")" && (a.indented = a.lexical.indented), a.lexical = a.lexical.prev) } function z(a, b) { var c = function () { var c = s.state; c.lexical = new p(c.indented, s.stream.column(), a, null, c.lexical, b) }; c.lex = !0; return c } function y() { s.state.localVars = s.state.context.vars, s.state.context = s.state.context.prev } function x() { s.state.context || (s.state.localVars = w), s.state.context = { prev: s.state.context, vars: s.state.localVars} } function v(a) { var b = s.state; if (b.context) { s.marked = "js-variabledef"; for (var c = b.localVars; c; c = c.next) if (c.name == a) return; b.localVars = { name: a, next: b.localVars} } } function u() { t.apply(null, arguments); return !0 } function t() { for (var a = arguments.length - 1; a >= 0; a--) s.cc.push(arguments[a]) } function r(a, b, c, e, f) { var g = a.cc; s.state = a, s.stream = f, s.marked = null, s.cc = g, a.lexical.hasOwnProperty("align") || (a.lexical.align = !0); for (; ; ) { var h = g.length ? g.pop() : d ? D : C; if (h(c, e)) { while (g.length && g[g.length - 1].lex) g.pop()(); if (s.marked) return s.marked; if (c == "variable" && q(a, e)) return "js-localvariable"; return b } } } function q(a, b) { for (var c = a.localVars; c; c = c.next) if (c.name == b) return !0 } function p(a, b, c, d, e, f) { this.indented = a, this.column = b, this.type = c, this.prev = e, this.info = f, d != null && (this.align = d) } function n(a, b) { var c = !1, d; while (d = a.next()) { if (d == "/" && c) { b.tokenize = l; break } c = d == "*" } return k("comment", "js-comment") } function m(a) { return function (b, c) { h(b, a) || (c.tokenize = l); return k("string", "js-string") } } function l(a, b) { var c = a.next(); if (c == '"' || c == "'") return g(a, b, m(c)); if (/[\[\]{}\(\),;\:\.]/.test(c)) return k(c); if (c == "0" && a.eat(/x/i)) { a.eatWhile(/[\da-f]/i); return k("number", "js-atom") } if (/\d/.test(c)) { a.match(/^\d*(?:\.\d*)?(?:e[+\-]?\d+)?/); return k("number", "js-atom") } if (c == "/") { if (a.eat("*")) return g(a, b, n); if (a.eat("/")) { a.skipToEnd(); return k("comment", "js-comment") } if (b.reAllowed) { h(a, "/"), a.eatWhile(/[gimy]/); return k("regexp", "js-string") } a.eatWhile(f); return k("operator", null, a.current()) } if (f.test(c)) { a.eatWhile(f); return k("operator", null, a.current()) } a.eatWhile(/[\w\$_]/); var d = a.current(), i = e.propertyIsEnumerable(d) && e[d]; return i ? k(i.type, i.style, d) : k("variable", "js-variable", d) } function k(a, b, c) { i = a, j = c; return b } function h(a, b) { var c = !1, d; while ((d = a.next()) != null) { if (d == b && !c) return !1; c = !c && d == "\\" } return c } function g(a, b, c) { b.tokenize = c; return c(a, b) } var c = a.indentUnit, d = b.json, e = function () { function a(a) { return { type: a, style: "js-keyword"} } var b = a("keyword a"), c = a("keyword b"), d = a("keyword c"), e = a("operator"), f = { type: "atom", style: "js-atom" }; return { "if": b, "while": b, "with": b, "else": c, "do": c, "try": c, "finally": c, "return": d, "break": d, "continue": d, "new": d, "delete": d, "throw": d, "var": a("var"), "function": a("function"), "catch": a("catch"), "for": a("for"), "switch": a("switch"), "case": a("case"), "default": a("default"), "in": e, "typeof": e, "instanceof": e, "true": f, "false": f, "null": f, "undefined": f, NaN: f, Infinity: f} } (), f = /[+\-*&%=<>!?|]/, i, j, o = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0 }, s = { state: null, column: null, marked: null, cc: null }, w = { name: "this", next: { name: "arguments"} }; A.lex = !0; return { startState: function (a) { return { tokenize: l, reAllowed: !0, cc: [], lexical: new p((a || 0) - c, 0, "block", !1), localVars: null, context: null, indented: 0} }, token: function (a, b) { a.sol() && (b.lexical.hasOwnProperty("align") || (b.lexical.align = !1), b.indented = a.indentation()); if (a.eatSpace()) return null; var c = b.tokenize(a, b); if (i == "comment") return c; b.reAllowed = i == "operator" || i == "keyword c" || i.match(/^[\[{}\(,;:]$/); return r(b, c, i, j, a) }, indent: function (a, b) { if (a.tokenize != l) return 0; var d = b && b.charAt(0), e = a.lexical, f = e.type, g = d == f; return f == "vardef" ? e.indented + 4 : f == "form" && d == "{" ? e.indented : f == "stat" || f == "form" ? e.indented + c : e.info == "switch" && !g ? e.indented + (/^(?:case|default)\b/.test(b) ? c : 2 * c) : e.align ? e.column + (g ? 0 : 1) : e.indented + (g ? 0 : c) }, electricChars: ":{}"} }), CodeMirror.defineMIME("text/javascript", "javascript"), CodeMirror.defineMIME("application/json", { name: "javascript", json: !0 }), CodeMirror.defineMode("xml", function (a, b) { function v(a) { if (a == "xml-word" && d.allowUnquoted) { m = "xml-attribute"; return o() } if (a == "xml-attribute") return o(); return n() } function u(a) { if (a == "xml-word") { m = "xml-attname"; return o(u) } if (a == "equals") return o(v, u); return n() } function t(a) { if (a == "endTag") return o(); return n() } function s(a) { return function (b) { if (b == "selfcloseTag" || b == "endTag" && d.autoSelfClosers.hasOwnProperty(l.tagName.toLowerCase())) return o(); if (b == "endTag") { p(l.tagName, a); return o() } return o() } } function r(a) { if (a == "openTag") { l.tagName = f; return o(u, s(l.startOfLine)) } if (a == "closeTag") { q(); return o(t) } if (a == "xml-cdata") { (!l.context || l.context.name != "!cdata") && p("!cdata"), l.tokenize == h && q(); return o() } return o() } function q() { l.context && (l.context = l.context.prev) } function p(a, b) { var c = d.doNotIndent.hasOwnProperty(a) || l.context && l.context.noIndent; l.context = { prev: l.context, tagName: a, indent: l.indented, startOfLine: b, noIndent: c} } function o() { n.apply(null, arguments); return !0 } function n() { for (var a = arguments.length - 1; a >= 0; a--) l.cc.push(arguments[a]) } function k(a, b) { return function (c, d) { while (!c.eol()) { if (c.match(b)) { d.tokenize = h; break } c.next() } return a } } function j(a) { return function (b, c) { while (!b.eol()) if (b.next() == a) { c.tokenize = i; break } return "xml-attribute" } } function i(a, b) { var c = a.next(); if (c == ">" || c == "/" && a.eat(">")) { b.tokenize = h, g = c == ">" ? "endTag" : "selfcloseTag"; return "xml-tag" } if (c == "=") { g = "equals"; return null } if (/[\'\"]/.test(c)) { b.tokenize = j(c); return b.tokenize(a, b) } a.eatWhile(/[^\s\u00a0=<>\"\'\/?]/); return "xml-word" } function h(a, b) { function c(c) { b.tokenize = c; return c(a, b) } var d = a.next(); if (d == "<") { if (a.eat("!")) { if (a.eat("[")) return a.match("[CDATA[") ? c(k("xml-cdata", "]]>")) : null; if (a.match("--")) return c(k("xml-comment", "-->")); if (a.match("DOCTYPE")) { a.eatWhile(/[\w\._\-]/); return c(k("xml-doctype", ">")) } return null } if (a.eat("?")) { a.eatWhile(/[\w\._\-]/); return c(k("xml-processing", "?>")) } g = a.eat("/") ? "closeTag" : "openTag", a.eatSpace(), f = ""; var e; while (e = a.eat(/[^\s\u00a0=<>\"\'\/?]/)) f += e; b.tokenize = i; return "xml-tag" } if (d == "&") { a.eatWhile(/[^;]/), a.eat(";"); return "xml-entity" } a.eatWhile(/[^&<]/); return null } var c = a.indentUnit, d = b.htmlMode ? { autoSelfClosers: { br: !0, img: !0, hr: !0, link: !0, input: !0, meta: !0, col: !0, frame: !0, base: !0, area: !0 }, doNotIndent: { pre: !0, "!cdata": !0 }, allowUnquoted: !0} : { autoSelfClosers: {}, doNotIndent: { "!cdata": !0 }, allowUnquoted: !1 }, e = b.alignCDATA, f, g, l, m; return { startState: function () { return { tokenize: h, cc: [], indented: 0, startOfLine: !0, tagName: null, context: null} }, token: function (a, b) { a.sol() && (b.startOfLine = !0, b.indented = a.indentation()); if (a.eatSpace()) return null; m = g = f = null; var c = b.tokenize(a, b); if ((c || g) && c != "xml-comment") { l = b; for (; ; ) { var d = b.cc.pop() || r; if (d(g || c)) break } } b.startOfLine = !1; return m || c }, indent: function (a, b) { var d = a.context; if (d && d.noIndent) return 0; if (e && /<!\[CDATA\[/.test(b)) return 0; d && /^<\//.test(b) && (d = d.prev); while (d && !d.startOfLine) d = d.prev; return d ? d.indent + c : 0 }, electricChars: "/"} }), CodeMirror.defineMIME("application/xml", "xml"), CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: !0 }), CodeMirror.defineMode("css", function (a) { function h(a) { return function (b, c) { var f = !1, g; while ((g = b.next()) != null) { if (g == a && !f) break; f = !f && g == "\\" } f || (c.tokenize = e); return d("css-string", "string") } } function g(a, b) { var c = 0, f; while ((f = a.next()) != null) { if (c >= 2 && f == ">") { b.tokenize = e; break } c = f == "-" ? c + 1 : 0 } return d("css-comment", "comment") } function f(a, b) { var c = !1, f; while ((f = a.next()) != null) { if (c && f == "/") { b.tokenize = e; break } c = f == "*" } return d("css-comment", "comment") } function e(a, b) { var c = a.next(); if (c == "@") { a.eatWhile(/\w/); return d("css-at", a.current()) } if (c == "/" && a.eat("*")) { b.tokenize = f; return f(a, b) } if (c == "<" && a.eat("!")) { b.tokenize = g; return g(a, b) } if (c == "=") d(null, "compare"); else { if (c != "~" && c != "|" || !a.eat("=")) { if (c == '"' || c == "'") { b.tokenize = h(c); return b.tokenize(a, b) } if (c == "#") { a.eatWhile(/\w/); return d("css-selector", "hash") } if (c == "!") { a.match(/^\s*\w*/); return d("css-important", "important") } if (/\d/.test(c)) { a.eatWhile(/[\w.%]/); return d("css-unit", "unit") } if (/[,.+>*\/]/.test(c)) return d(null, "select-op"); if (/[;{}:\[\]]/.test(c)) return d(null, c); a.eatWhile(/[\w\\\-_]/); return d("css-identifier", "identifier") } return d(null, "compare") } } function d(a, b) { c = b; return a } var b = a.indentUnit, c; return { startState: function (a) { return { tokenize: e, baseIndent: a || 0, stack: []} }, token: function (a, b) { if (a.eatSpace()) return null; var d = b.tokenize(a, b), e = b.stack[b.stack.length - 1]; if (c == "hash" && e == "rule") d = "css-colorcode"; else if (d == "css-identifier") if (e == "rule") d = "css-value"; else if (!e || e == "@media{") d = "css-selector"; e == "rule" && /^[\{\};]$/.test(c) && b.stack.pop(), c == "{" ? e == "@media" ? b.stack[b.stack.length - 1] = "@media{" : b.stack.push("{") : c == "}" ? b.stack.pop() : c == "@media" ? b.stack.push("@media") : e != "rule" && e != "@media" && c != "comment" && b.stack.push("rule"); return d }, indent: function (a, c) { var d = a.stack.length; /^\}/.test(c) && (d -= a.stack[a.stack.length - 1] == "rule" ? 2 : 1); return a.baseIndent + d * b }, electricChars: "}"} }), CodeMirror.defineMIME("text/css", "css"), CodeMirror.defineMode("htmlmixed", function (a, b) { function h(a, b) { if (a.match(/^<\/\s*style\s*>/i, !1)) { b.token = f, b.localState = null; return f(a, b) } return e.token(a, b.localState) } function g(a, b) { if (a.match(/^<\/\s*script\s*>/i, !1)) { b.token = f, b.curState = null; return f(a, b) } return d.token(a, b.localState) } function f(a, b) { var f = c.token(a, b.htmlState); f == "xml-tag" && a.current() == ">" && b.htmlState.context && (/^script$/i.test(b.htmlState.context.tagName) ? (b.token = g, b.localState = d.startState(c.indent(b.htmlState, ""))) : /^style$/i.test(b.htmlState.context.tagName) && (b.token = h, b.localState = e.startState(c.indent(b.htmlState, "")))); return f } var c = CodeMirror.getMode(a, { name: "xml", htmlMode: !0 }), d = CodeMirror.getMode(a, "javascript"), e = CodeMirror.getMode(a, "css"); return { startState: function () { var a = c.startState(); return { token: f, localState: null, htmlState: a} }, copyState: function (a) { if (a.localState) var b = CodeMirror.copyState(a.token == h ? e : d, a.localState); return { token: a.token, localState: b, htmlState: CodeMirror.copyState(c, a.htmlState)} }, token: function (a, b) { return b.token(a, b) }, indent: function (a, b) { return a.token == f || /^\s*<\//.test(b) ? c.indent(a.htmlState, b) : a.token == g ? d.indent(a.localState, b) : e.indent(a.localState, b) }, electricChars: "/{}:"} }), CodeMirror.defineMIME("text/html", "htmlmixed"), CodeMirror.defineMode("clike", function (a, b) { function p(a) { return a.context = a.context.prev } function o(a, b, c) { return a.context = new n(a.indented, b, c, null, a.context) } function n(a, b, c, d, e) { this.indented = a, this.column = b, this.type = c, this.align = d, this.prev = e } function m(a, b) { var c = !1, d; while (d = a.next()) { if (d == "/" && c) { b.tokenize = k; break } c = d == "*" } return j("comment", "c-like-comment") } function l(a) { return function (b, c) { g(b, a) || (c.tokenize = k); return j("string", "c-like-string") } } function k(a, b) { var c = a.next(); if (c == '"' || c == "'") return h(a, b, l(c)); if (/[\[\]{}\(\),;\:\.]/.test(c)) return j(c); if (c == "#" && e && b.startOfLine) { a.skipToEnd(); return j("directive", "c-like-preprocessor") } if (/\d/.test(c)) { a.eatWhile(/[\w\.]/); return j("number", "c-like-number") } if (c == "/") { if (a.eat("*")) return h(a, b, m); if (a.eat("/")) { a.skipToEnd(); return j("comment", "c-like-comment") } a.eatWhile(f); return j("operator") } if (f.test(c)) { a.eatWhile(f); return j("operator") } a.eatWhile(/[\w\$_]/); if (d && d.propertyIsEnumerable(a.current())) return j("keyword", "c-like-keyword"); return j("word", "c-like-word") } function j(a, b) { i = a; return b } function h(a, b, c) { b.tokenize = c; return c(a, b) } function g(a, b) { var c = !1, d; while ((d = a.next()) != null) { if (d == b && !c) return !1; c = !c && d == "\\" } return c } var c = a.indentUnit, d = b.keywords, e = b.useCPP, f = /[+\-*&%=<>!?|]/, i; return { startState: function (a) { return { tokenize: k, context: new n((a || 0) - c, "top", !1), indented: 0, startOfLine: !0} }, token: function (a, b) { var c = b.context; a.sol() && (c.align == null && (c.align = !1), b.indented = a.indentation(), b.startOfLine = !0); if (a.eatSpace()) return null; var d = b.tokenize(a, b); if (i == "comment") return d; c.align == null && (c.align = !0), i != ";" && i != ":" || c.type != "statement" ? i == "{" ? o(b, a.column(), "}") : i == "[" ? o(b, a.column(), "]") : i == "(" ? o(b, a.column(), ")") : i == "}" ? (c.type == "statement" && (c = p(b)), c.type == "}" && (c = p(b)), c.type == "statement" && (c = p(b))) : i == c.type ? p(b) : c.type == "}" && o(b, a.column(), "statement") : p(b), b.startOfLine = !1; return d }, indent: function (a, b) { if (a.tokenize != k) return 0; var d = b && b.charAt(0), e = a.context, f = d == e.type; return e.type == "statement" ? e.indented + (d == "{" ? 0 : c) : e.align ? e.column + (f ? 0 : 1) : e.indented + (f ? 0 : c) }, electricChars: "{}"} }), function () { function a(a) { var b = {}, c = a.split(" "); for (var d = 0; d < c.length; ++d) b[c[d]] = !0; return b } var b = "auto if break int case long char register continue return default short do sizeof double static else struct entry switch extern typedef float union for unsigned goto while enum void const signed volatile"; CodeMirror.defineMIME("text/x-csrc", { name: "clike", useCPP: !0, keywords: a(b) }), CodeMirror.defineMIME("text/x-c++src", { name: "clike", useCPP: !0, keywords: a(b + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " + "static_cast typeid catch false operator template typename class friend private " + "this using const_cast inline public throw virtual delete mutable protected true " + "wchar_t") }), CodeMirror.defineMIME("text/x-java", { name: "clike", keywords: a("abstract assert boolean break byte case catch char class const continue default do double else enum extends false final finally float for goto if implements import instanceof int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient true try void volatile while") }) } (), CodeMirror.defineMode("diff", function () { return { token: function (a) { var b = a.next(); a.skipToEnd(); if (b == "+") return "diff-plus"; if (b == "-") return "diff-minus"; if (b == "@") return "diff-rangeinfo" } } }), CodeMirror.defineMIME("text/x-diff", "diff")